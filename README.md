# payhere 사전과제

### 실행방법
도커가 설치된 환경에서 다운받으신 프로젝트 내에 docker-compose.yml이 위치한 경로에서
``` 
docker-compose up -d
``` 
명령어 실행해주시면 애플리케이션이 동작합니다.

### 개발환경
 - SpringBoot 3.1.8
 - Redis
 - Mysql 5.7

### 구현내용
> 판매자
 - 회원가입 (POST : /seller)
   - 휴대폰번호, 비밀번호를 입력받아 판매자 회원가입을 수행합니다.
   - 사용자 휴대폰번호는 유니크 제약조건으로 중복가입을 방지했습니다.
   - 사용자 비밀번호는 단방향 암호화 알고리즘을 사용하여 저장합니다.
   - 회원가입 완료 시 UserSessionManager 클래스 내에서 Jwt토큰을 생성하고 Redis에 저장합니다.
   - Jwt토큰 유효시간 및 Redis에 TTL시간은 한번 로그인하면 평균 영업시간 내 <br>
     재로그인하는 번거로움이 없게 하기위해 12시간으로 설정했으며 <br>
     RefreshToken은 시간이 부족하여 이번 과제에서는 제외했습니다.
   - 로그인 세션 데이터 구조는 판매자가 여러 단말기에서 상품을 추가,수정 가능하게 <br> 중복로그인을 허용하는 구조로 구성되어있습니다. <br><br>

 - 로그인 (POST : /login)
   - 휴대폰번호, 비밀번호를 입력받아 판매자가 있는지 조회 후 로그인을 수행합니다.
   - 입력한 휴대폰번호로 판매자 정보를 조회 후 존재하지 않으면 에러응답을 반환합니다.
   - 로그인 성공 시 UserSessionManager 클래스 내에서 Jwt토큰을 생성하고 Redis에 저장합니다. <br><br> 
   
 - 로그아웃 (POST : /logout)
   - AUTHORIZATION 헤더로 로그인 시에 발급받은 토큰정보를 전달받아 로그아웃을 수행합니다.
   - 로그아웃은 ArgumentResolver를 이용하여 헤더에서 전달받은 토큰이 유효한지 검증하며, <br>
     해당 토큰이 Redis에 존재하는지 검사하여 유효성을 판단합니다. <br>
     만약 Jwt토큰이 만료되었거나 Redis에 존재하지 않는다면 유효하지 않은 토큰으로 에러를 반환합니다.
   - ArgumentResolver를 통해 전달받은 토큰을 Redis에서 제거하는것으로 로그아웃 기능을 지원합니다.
   
> 상품
 - 공통사항
   - 상품관련 API 들은 로그인, 회원가입에서 발급한 토큰정보를 기반으로 동작합니다.
   - 상품관련 API 들은 로그인한 판매자가 등록한 상품에 한해서만 등록, 수정, 삭제가 가능합니다. 
   - 만약 토큰이 만료되었거나 유효하지않다면 상품관련 API를 호출했을 경우 재로그인요청 응답을 리턴합니다. <br><br>
   
 - 상품 등록 (POST : /product)
   - 카테고리, 가격, 원가, 상품명, 설명, 바코드, 사이즈를 입력받아 상품정보를 저장합니다.
   - 각 파라미터들은 Validation 기반에 값검증을 수행합니다.
   - 각 상품들은 초성검색을 위해 상품명 띄어쓰기를 기준으로 구분하여 각 명칭에 초성값을 보유하며, <br>
     상품생성, 수정, 삭제에 관련하여 라이프사이클을 같이 가져갑니다.
   - 상품 생성시에 상품명을 기준으로 초성정보를 생성하여 저장합니다.
   - 각 상품들은 판매자에 의존성 매핑되어있습니다. 개선한다면 판매자가 보유한 매장별로 상품을 매핑할 예정입니다.
   - 상품은 카페 판매 상품으로 생각하고 구현하여 재고를 구현하진 않았습니다. <br> 
     만약 재고를 구현한다면 동시성제어를 위해 Redis 기반에 재고관리기능을 구현할 생각입니다. <br>
     다만 이번상품에서는 판매자가 자체적으로 판단하여 상품상태정보를 '중지' 상태로 변경할 수 있습니다. <br><br>

 - 상품 수정 (PUT : /product)
   - 카테고리, 가격, 원가, 상품명, 설명, 바코드, 사이즈를 입력받아 상품정보를 수정합니다.
   - 상품명이 변경되었다면 변경된 상품명을 기준으로 기존 초성정보를 삭제하고 새로운 초성정보를 저장합니다. <br><br>

 - 상품 삭제 (DELETE : /product)
   - 상품식별번호를 기반으로 상품정보를 삭제합니다.
   - 상품정보가 존재하지 않을 경우 에러를 응답합니다. <br><br>

 - 상품 상세조회 (GET : /product/{id})
   - 상품식별정보를 기반으로 상품정보를 응답합니다.
   - 조회한 상품에 유통기한이 만료되었다면 상품상태는 '중지' 상태로 응답합니다. <br><br>
   
 - 상품 페이징 조회 (GET : /product)
   - 상품을 커서기반에 페이징조회하여 응답합니다.
   - 상품조회 Size는 기본 10개이며 변경요청 가능합니다.
   - 상품 페이징 조회는 상품식별번호를 기준으로 정렬되어 조회됩니다.
   - 정렬기준을 파라미터로 입력받아 다양한 옵션으로 조회해볼 수 있겠지만 현재는 상품식별번호를 기준으로만 페이징처리되고 있습니다.
   ``` 
    val key: Long? = null, // 초기값은 null 두번째 페이징 요청부터 조회할 기준 키값을 설정
    val size: Int = 10 
   ```
   - 응답시 다음으로 요청해야할 키값을 리턴하며, 조회된 상품정보를 응답합니다.
   - 이후 더이상 데이터가 없다면 응답 nextProductSearchCursorRequest.Key 값은 -1을 리턴합니다.
   ``` 
    {
        "meta": {
            "code": 200,
            "message": "ok"
        },
        "data": {
            "nextProductSearchCursorRequest": {
                 "key": 2,
                 "size": 10
            },
            "products": [...]
        }
    }
   ```
   <br>
 - 상품 단어 검색 (GET : /product)
   - 상품 단어검색은 입력한 값을 기준으로 상품테이블에 Like 검색을 수행 후 데이터가 있다면 응답합니다.
   - 만약 상품테이블에 Like 검색결과가 없다면 상품초성테이블에 질의하는식으로 수행합니다.
   ``` 
   '슈크림' -> 상품테이블 Like 검색 리턴
   'ㅅㅋㄹ' -> 상품테이블 Like 검색 -> 초성테이블 검색 리턴
   ```
   - 상품 초성검색은 판매자별 등록된 초성을 기준으로 비교하여 판매자, 초성으로 복합인덱스가 걸려있습니다.
   - 현재 검색 프로세스는 단순하지만 초성데이터, 상품데이터는 운영환경에서 대용량 데이터일것으로 사용자 검색 패턴에 따라 인덱스 구성 및 프로세스를 개선 후 캐싱을 적용하여 많은 트래픽에 대응해야 할 것으로 생각하고 있습니다. <br>

### 추후 개선사항
 - RefreshToken 적용
 - 상품 조회 기능 API Redis 캐싱 적용
 - 판매자 <-> 상품 구조에서 판매자 <-> 사업장 <-> 상품 구조로 변경
 - 상품 String 타입에 카테고리 매장별 카테고리로 DB 내재화
 - 페이징 쿼리 정렬조건 추가 및 DB 인덱스 추가
 - 페이징 처리를 범용적으로 사용할 수 있게 공통화 처리
 - 테스트 코드 케이스 세분화